<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Porch Couch</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #2B3C4D; /* Darker grey-blue background */
      position: relative;
    }
    /* Each moving wrapper contains a gif and an overlaid label */
    .hover-wrapper {
      position: absolute;
      width: 300px;
      cursor: pointer;
    }
    .hover-wrapper img {
      width: 100%;
      display: block;
    }
    /* The label that appears on hover */
    .hover-wrapper .label {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 36px;
      background: rgba(0,0,0,0.5);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    /* Porch click text in the upper right corner */
    #porchClick {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 18px;
      color: white;
      z-index: 20;
    }
    #porchClick a {
      color: white;
      text-decoration: none;
    }
    /* Video overlay styles */
    #videoOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #videoOverlay iframe {
      width: 80%;
      height: 80%;
      border: none;
    }
  </style>
</head>
<body>
  <!-- Three hover wrappers for the three GIFs -->
  <div class="hover-wrapper floating" id="wrapper1">
    <img src="blur1.gif" data-default="blur1.gif" data-hover="blur2.jpg" data-label="where am i?" data-link="who.html">
    <div class="label"></div>
  </div>
  <div class="hover-wrapper floating" id="wrapper2">
    <img src="eat2.gif" data-default="eat2.gif" data-hover="couch.png" data-label="tour" data-link="tour.html">
    <div class="label"></div>
  </div>
  <div class="hover-wrapper floating" id="wrapper3">
    <img src="smile2.gif" data-default="smile2.gif" data-hover="store.jpg" data-label="shop" data-link="shop.html">
    <div class="label"></div>
  </div>

  <!-- Porch click text in the upper right -->
  <div id="porchClick"><a href="#" id="porchClickLink">porch click</a></div>

  <!-- Video Overlay -->
  <div id="videoOverlay">
    <iframe id="videoFrame" src="" frameborder="0" allowfullscreen></iframe>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const wrappers = document.querySelectorAll('.hover-wrapper');
      const speedFactor = 1.08; // 8% faster
      const movingObjects = []; // holds each wrapper's state

      // Initialize each wrapper with a random starting position and small random velocities.
      wrappers.forEach(wrapper => {
        const rect = wrapper.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        const posX = Math.random() * (window.innerWidth - width);
        const posY = Math.random() * (window.innerHeight - height);
        // Base velocities multiplied by speedFactor (in pixels per frame)
        const velX = (Math.random() * 2 - 1) * 0.5 * speedFactor;
        const velY = (Math.random() * 2 - 1) * 0.5 * speedFactor;
        movingObjects.push({ element: wrapper, posX, posY, velX, velY, width, height });
      });

      // Animation loop: update positions, handle collisions and screen bounces.
      function updatePositions() {
        // Update each object's position and bounce off screen edges.
        movingObjects.forEach(obj => {
          obj.posX += obj.velX;
          obj.posY += obj.velY;

          // Bounce off left/right edges:
          if (obj.posX < 0) {
            obj.posX = 0;
            obj.velX = -obj.velX;
          } else if (obj.posX + obj.width > window.innerWidth) {
            obj.posX = window.innerWidth - obj.width;
            obj.velX = -obj.velX;
          }

          // Bounce off top/bottom edges:
          if (obj.posY < 0) {
            obj.posY = 0;
            obj.velY = -obj.velY;
          } else if (obj.posY + obj.height > window.innerHeight) {
            obj.posY = window.innerHeight - obj.height;
            obj.velY = -obj.velY;
          }
        });

        // Check collisions between wrappers and bounce them off each other.
        for (let i = 0; i < movingObjects.length; i++) {
          for (let j = i + 1; j < movingObjects.length; j++) {
            const a = movingObjects[i];
            const b = movingObjects[j];
            if (
              a.posX < b.posX + b.width &&
              a.posX + a.width > b.posX &&
              a.posY < b.posY + b.height &&
              a.posY + a.height > b.posY
            ) {
              // Simple bounce: reverse velocities.
              a.velX = -a.velX;
              a.velY = -a.velY;
              b.velX = -b.velX;
              b.velY = -b.velY;
              // Nudge them apart.
              a.posX += a.velX * 2;
              a.posY += a.velY * 2;
              b.posX += b.velX * 2;
              b.posY += b.velY * 2;
            }
          }
        }

        // Apply updated positions.
        movingObjects.forEach(obj => {
          obj.element.style.transform = `translate(${obj.posX}px, ${obj.posY}px)`;
        });
        requestAnimationFrame(updatePositions);
      }
      updatePositions();

      // Setup hover events on each wrapper.
      wrappers.forEach(wrapper => {
        const img = wrapper.querySelector('img');
        const label = wrapper.querySelector('.label');

        wrapper.addEventListener('mouseover', function() {
          // Save original src if not already saved.
          if (!img.dataset.original) {
            img.dataset.original = img.src;
          }
          // Stop movement by setting velocity to 0.
          const obj = movingObjects.find(o => o.element === wrapper);
          if (!img.dataset.originalVelX) {
            img.dataset.originalVelX = obj.velX;
            img.dataset.originalVelY = obj.velY;
          }
          obj.velX = 0;
          obj.velY = 0;
          // Swap image and show label.
          img.src = img.getAttribute('data-hover');
          label.innerText = img.getAttribute('data-label');
          label.style.opacity = 1;
        });

        wrapper.addEventListener('mouseout', function() {
          // Restore image and resume movement.
          img.src = img.dataset.original;
          label.style.opacity = 0;
          const obj = movingObjects.find(o => o.element === wrapper);
          obj.velX = parseFloat(img.dataset.originalVelX);
          obj.velY = parseFloat(img.dataset.originalVelY);
        });

        // On click, navigate to the linked page.
        wrapper.addEventListener('click', function(event) {
          event.stopPropagation();
          window.location.href = img.getAttribute('data-link');
        });
      });

      // Porch click link (upper right) opens the video overlay.
      document.getElementById('porchClickLink').addEventListener('click', function(event) {
        event.preventDefault();
        document.getElementById('videoFrame').src = "https://www.youtube.com/embed/j1AsH3Wigp0?autoplay=1";
        document.getElementById('videoOverlay').style.display = "flex";
      });

      // Video overlay close behavior.
      document.getElementById('videoOverlay').addEventListener('click', function(event) {
        if (event.target === this) {
          this.style.display = "none";
          document.getElementById('videoFrame').src = "";
        }
      });

      document.addEventListener("keydown", function(event) {
        if (event.key === "Escape") {
          document.getElementById('videoOverlay').style.display = "none";
          document.getElementById('videoFrame').src = "";
        }
      });

      // Update dimensions on window resize.
      window.addEventListener('resize', function() {
        movingObjects.forEach(obj => {
          const rect = obj.element.getBoundingClientRect();
          obj.width = rect.width;
          obj.height = rect.height;
        });
      });
    });
  </script>
</body>
</html>
